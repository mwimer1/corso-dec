#!/usr/bin/env sh
. "$(dirname -- "$0")/husky.sh"

# husky.sh already changes to the git repository root
# Verify we're in a git repository (use --show-toplevel which is more reliable)
if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
  # Fallback: ensure we're in repo root using relative path (Windows compatibility)
  cd "$(dirname -- "$0")/../.." || exit 1
  if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
    echo "âœ– Error: Could not find git repository root"
    exit 1
  fi
fi

echo "ðŸ” Running local quality gates..."

# Helper function to check if file is staged (cross-platform compatible)
has_staged_file() {
  git diff --cached --name-only --diff-filter=ACMR | grep -q "$1"
}

# Track which checks we need to run
NEEDS_PACKAGE_CHECK=false
NEEDS_ENV_CHECK=false
NEEDS_TYPECHECK=false
NEEDS_LINT=false
NEEDS_DOCS_CHECK=false

# Determine which checks are needed
if has_staged_file "^package.json$"; then
  NEEDS_PACKAGE_CHECK=true
fi

# Check for env-related config files
for pattern in "package.json" "next.config" "tsconfig.json" ".env.example" ".env.test" "config/.*env"; do
  if git diff --cached --name-only | grep -qE "$pattern"; then
    NEEDS_ENV_CHECK=true
    break
  fi
done

# Check if TypeScript files are staged
if git diff --cached --name-only | grep -qE '\.(ts|tsx)$'; then
  NEEDS_TYPECHECK=true
  NEEDS_LINT=true
fi

# Check if docs files are staged
if git diff --cached --name-only | grep -qE '(^docs/|README\.md|\.husky/.*\.md|\.cursor/.*\.md)'; then
  NEEDS_DOCS_CHECK=true
fi

# Count total checks for progress display
TOTAL_CHECKS=0
[ "$NEEDS_PACKAGE_CHECK" = "true" ] && TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
[ "$NEEDS_ENV_CHECK" = "true" ] && TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
[ "$NEEDS_TYPECHECK" = "true" ] && TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
[ "$NEEDS_LINT" = "true" ] && TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
[ "$NEEDS_DOCS_CHECK" = "true" ] && TOTAL_CHECKS=$((TOTAL_CHECKS + 1))

# Add leak guard check
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))

CHECK_NUM=0
EXIT_CODE=0

# Parallel execution: Run independent checks concurrently
# Package and Env validation can run in parallel (both check config, no dependencies)
# Typecheck and lint can run in parallel (both work on staged TS files)
# Docs validation can run in parallel with everything

# Run package validation (if needed)
if [ "$NEEDS_PACKAGE_CHECK" = "true" ]; then
  CHECK_NUM=$((CHECK_NUM + 1))
  echo "[$CHECK_NUM/$TOTAL_CHECKS] Validating package.json..."
  pnpm validate:package &
  PACKAGE_PID=$!
else
  echo "â­ï¸  Validating package.json... (skipped - package.json not changed)"
fi

# Run env validation (if needed) - in parallel with package check
if [ "$NEEDS_ENV_CHECK" = "true" ]; then
  CHECK_NUM=$((CHECK_NUM + 1))
  echo "[$CHECK_NUM/$TOTAL_CHECKS] Validating environment..."
  NODE_ENV=development pnpm validate:env &
  ENV_PID=$!
else
  echo "â­ï¸  Validating environment... (skipped - no env-related files changed)"
fi

# Wait for package/env validations to complete
if [ "$NEEDS_PACKAGE_CHECK" = "true" ]; then
  wait $PACKAGE_PID || EXIT_CODE=$?
fi
if [ "$NEEDS_ENV_CHECK" = "true" ]; then
  wait $ENV_PID || EXIT_CODE=$?
fi

# Exit early if validations failed
if [ $EXIT_CODE -ne 0 ]; then
  exit $EXIT_CODE
fi

# Run typecheck and lint in parallel (both work on staged TS files)
# Parallel execution enabled by default; set HUSKY_PARALLEL=0 to disable
HUSKY_PARALLEL=${HUSKY_PARALLEL:-1}

# Determine execution strategy
RUN_PARALLEL=false
if [ "$NEEDS_TYPECHECK" = "true" ] && [ "$NEEDS_LINT" = "true" ] && [ "$HUSKY_PARALLEL" = "1" ]; then
  RUN_PARALLEL=true
fi

if [ "$RUN_PARALLEL" = "true" ]; then
  # Run both in parallel for faster execution
  CHECK_NUM=$((CHECK_NUM + 1))
  echo "[$CHECK_NUM/$TOTAL_CHECKS] Type checking staged files..."
  pnpm typecheck:staged &
  TYPECHECK_PID=$!
  
  CHECK_NUM=$((CHECK_NUM + 1))
  echo "[$CHECK_NUM/$TOTAL_CHECKS] Linting staged files..."
  pnpm lint-staged &
  LINT_PID=$!
  
  # Wait for both and capture exit codes
  TYPECHECK_EXIT=0
  LINT_EXIT=0
  wait $TYPECHECK_PID || TYPECHECK_EXIT=$?
  wait $LINT_PID || LINT_EXIT=$?
  
  # Fail if either failed
  if [ $TYPECHECK_EXIT -ne 0 ] || [ $LINT_EXIT -ne 0 ]; then
    if [ $TYPECHECK_EXIT -ne 0 ]; then
      EXIT_CODE=$TYPECHECK_EXIT
    fi
    if [ $LINT_EXIT -ne 0 ]; then
      EXIT_CODE=$LINT_EXIT
    fi
    exit $EXIT_CODE
  fi
else
  # Sequential execution (when only one needed, or parallel disabled)
  if [ "$NEEDS_TYPECHECK" = "true" ]; then
    CHECK_NUM=$((CHECK_NUM + 1))
    echo "[$CHECK_NUM/$TOTAL_CHECKS] Type checking staged files..."
    pnpm typecheck:staged || EXIT_CODE=$?
    if [ $EXIT_CODE -ne 0 ]; then
      exit $EXIT_CODE
    fi
  else
    echo "â­ï¸  Type checking staged files... (skipped - no TypeScript files changed)"
  fi

  if [ "$NEEDS_LINT" = "true" ]; then
    CHECK_NUM=$((CHECK_NUM + 1))
    echo "[$CHECK_NUM/$TOTAL_CHECKS] Linting staged files..."
    pnpm lint-staged || EXIT_CODE=$?
    if [ $EXIT_CODE -ne 0 ]; then
      exit $EXIT_CODE
    fi
  else
    echo "â­ï¸  Linting staged files... (skipped - no code files changed)"
  fi
fi

# Run docs validation (can run in parallel with others, but keeping sequential for cleaner output)
# Note: validate-docs-on-commit.ts was removed - docs validation is now handled by CI
if [ "$NEEDS_DOCS_CHECK" = "true" ]; then
  echo "â­ï¸  Validating documentation freshness... (skipped - validation moved to CI)"
else
  echo "â­ï¸  Validating documentation freshness... (skipped - no docs files changed)"
fi

# --- Leak Guard ---
# Fast-fail if critical types are re-exported from shared barrels.
grep -R "export .*Database" types/shared >/dev/null 2>&1 && {
  echo "âœ– FATAL: Critical type 'Database' is being re-exported from types/shared."
  echo "  This violates architectural boundaries. Please import it from its source."
  exit 1;
}
# --- End Leak Guard ---

echo "âœ… All local quality gates passed! Ready for CI."
