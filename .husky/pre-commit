#!/usr/bin/env sh
. "$(dirname -- "$0")/husky.sh"

# husky.sh already changes to the git repository root
# Verify we're in a git repository (use --show-toplevel which is more reliable)
if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
  # Fallback: ensure we're in repo root using relative path (Windows compatibility)
  cd "$(dirname -- "$0")/../.." || exit 1
  if ! git rev-parse --show-toplevel >/dev/null 2>&1; then
    echo "âœ– Error: Could not find git repository root"
    exit 1
  fi
fi

echo "ðŸ” Running local quality gates..."

# Helper function to check if file is staged (cross-platform compatible)
has_staged_file() {
  git diff --cached --name-only --diff-filter=ACMR | grep -q "$1"
}

# Track which checks we need to run
NEEDS_PACKAGE_CHECK=false
NEEDS_ENV_CHECK=false
NEEDS_TYPECHECK=false
NEEDS_LINT=false
NEEDS_DOCS_CHECK=false

# Determine which checks are needed
if has_staged_file "^package.json$"; then
  NEEDS_PACKAGE_CHECK=true
fi

# Check for env-related config files
for pattern in "package.json" "next.config" "tsconfig.json" ".env.example" ".env.test" "config/.*env"; do
  if git diff --cached --name-only | grep -qE "$pattern"; then
    NEEDS_ENV_CHECK=true
    break
  fi
done

# Check if TypeScript files are staged
if git diff --cached --name-only | grep -qE '\.(ts|tsx)$'; then
  NEEDS_TYPECHECK=true
  NEEDS_LINT=true
fi

# Check if docs files are staged
if git diff --cached --name-only | grep -qE '(^docs/|README\.md|\.husky/.*\.md|\.cursor/.*\.md)'; then
  NEEDS_DOCS_CHECK=true
fi

# Count total checks for progress display
TOTAL_CHECKS=0
[ "$NEEDS_PACKAGE_CHECK" = "true" ] && TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
[ "$NEEDS_ENV_CHECK" = "true" ] && TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
[ "$NEEDS_TYPECHECK" = "true" ] && TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
[ "$NEEDS_LINT" = "true" ] && TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
[ "$NEEDS_DOCS_CHECK" = "true" ] && TOTAL_CHECKS=$((TOTAL_CHECKS + 1))

# Add leak guard check
TOTAL_CHECKS=$((TOTAL_CHECKS + 1))

CHECK_NUM=0
EXIT_CODE=0

# Parallel execution: Run independent checks concurrently
# Package and Env validation can run in parallel (both check config, no dependencies)
# Typecheck and lint can run in parallel (both work on staged TS files)
# Docs validation can run in parallel with everything

# Run package validation (if needed)
if [ "$NEEDS_PACKAGE_CHECK" = "true" ]; then
  CHECK_NUM=$((CHECK_NUM + 1))
  echo "[$CHECK_NUM/$TOTAL_CHECKS] Validating package.json..."
  pnpm validate:package &
  PACKAGE_PID=$!
else
  echo "â­ï¸  Validating package.json... (skipped - package.json not changed)"
fi

# Run env validation (if needed) - in parallel with package check
if [ "$NEEDS_ENV_CHECK" = "true" ]; then
  CHECK_NUM=$((CHECK_NUM + 1))
  echo "[$CHECK_NUM/$TOTAL_CHECKS] Validating environment..."
  NODE_ENV=development pnpm validate:env &
  ENV_PID=$!
else
  echo "â­ï¸  Validating environment... (skipped - no env-related files changed)"
fi

# Wait for package/env validations to complete
if [ "$NEEDS_PACKAGE_CHECK" = "true" ]; then
  wait $PACKAGE_PID || EXIT_CODE=$?
fi
if [ "$NEEDS_ENV_CHECK" = "true" ]; then
  wait $ENV_PID || EXIT_CODE=$?
fi

# Exit early if validations failed
if [ $EXIT_CODE -ne 0 ]; then
  exit $EXIT_CODE
fi

# Run typecheck and lint in parallel (both work on staged TS files)
# Note: We could run these truly in parallel, but keeping them sequential for now
# to ensure type errors are caught before linting (better error messages)
if [ "$NEEDS_TYPECHECK" = "true" ]; then
  CHECK_NUM=$((CHECK_NUM + 1))
  echo "[$CHECK_NUM/$TOTAL_CHECKS] Type checking staged files..."
  pnpm typecheck:staged || EXIT_CODE=$?
  if [ $EXIT_CODE -ne 0 ]; then
    exit $EXIT_CODE
  fi
else
  echo "â­ï¸  Type checking staged files... (skipped - no TypeScript files changed)"
fi

if [ "$NEEDS_LINT" = "true" ]; then
  CHECK_NUM=$((CHECK_NUM + 1))
  echo "[$CHECK_NUM/$TOTAL_CHECKS] Linting staged files..."
  pnpm lint-staged || EXIT_CODE=$?
  if [ $EXIT_CODE -ne 0 ]; then
    exit $EXIT_CODE
  fi
else
  echo "â­ï¸  Linting staged files... (skipped - no code files changed)"
fi

# Run docs validation (can run in parallel with others, but keeping sequential for cleaner output)
if [ "$NEEDS_DOCS_CHECK" = "true" ]; then
  CHECK_NUM=$((CHECK_NUM + 1))
  echo "[$CHECK_NUM/$TOTAL_CHECKS] Validating documentation freshness..."
  pnpm tsx scripts/maintenance/validate-docs-on-commit.ts || EXIT_CODE=$?
  if [ $EXIT_CODE -ne 0 ]; then
    exit $EXIT_CODE
  fi
else
  echo "â­ï¸  Validating documentation freshness... (skipped - no docs files changed)"
fi

# --- Leak Guard ---
# Fast-fail if critical types are re-exported from shared barrels.
grep -R "export .*Database" types/shared >/dev/null 2>&1 && {
  echo "âœ– FATAL: Critical type 'Database' is being re-exported from types/shared."
  echo "  This violates architectural boundaries. Please import it from its source."
  exit 1;
}
# --- End Leak Guard ---

echo "âœ… All local quality gates passed! Ready for CI."
