#!/usr/bin/env sh
. "$(dirname -- "$0")/husky.sh"

# Fail-fast pre-commit hook with low-noise output and high-context failures

# Get git directory for log storage
GIT_DIR=$(git rev-parse --git-dir 2>/dev/null || echo ".git")
LOG_DIR="$GIT_DIR/husky-logs"
mkdir -p "$LOG_DIR"

# Generate log file name with timestamp
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
LOG_FILE="$LOG_DIR/pre-commit-$TIMESTAMP.log"

# Verbose mode: stream output instead of logging
if [ "$HUSKY_VERBOSE" = "1" ]; then
  LOG_CMD=""
  LOG_SUFFIX=""
else
  LOG_CMD=">> \"$LOG_FILE\" 2>&1"
  LOG_SUFFIX=" (see $LOG_FILE)"
fi

# Helper to run a gate and capture exit code
run_gate() {
  local gate_name="$1"
  local command="$2"
  local condition="$3"
  
  if [ -n "$condition" ] && ! eval "$condition"; then
    echo "â­ï¸  $gate_name... (skipped)"
    return 0
  fi
  
  echo "ğŸ” $gate_name..."
  
  if [ "$HUSKY_VERBOSE" = "1" ]; then
    eval "$command"
    local exit_code=$?
  else
    eval "$command >> \"$LOG_FILE\" 2>&1"
    local exit_code=$?
  fi
  
  if [ $exit_code -ne 0 ]; then
    return $exit_code
  fi
  
  echo "âœ… $gate_name"
  return 0
}

# Helper to check if file pattern is staged
has_staged_file() {
  git diff --cached --name-only --diff-filter=ACMR | grep -qE "$1"
}

# Helper to show failure context
show_failure() {
  local gate_name="$1"
  local command="$2"
  
  echo ""
  echo "âŒ Pre-commit failed: $gate_name"
  echo ""
  echo "ğŸ“‹ Action items:"
  echo "  1. Fix the errors shown above"
  echo "  2. Re-run: $command"
  echo "  3. View full log: $LOG_FILE"
  echo ""
  
  if [ "$HUSKY_VERBOSE" != "1" ] && [ -f "$LOG_FILE" ]; then
    echo "ğŸ“„ Last 200 lines of log:"
    echo "---"
    tail -n 200 "$LOG_FILE" 2>/dev/null || echo "(log file not readable)"
    echo "---"
  fi
  
  exit 1
}

# Initialize log file
if [ "$HUSKY_VERBOSE" != "1" ]; then
  echo "Pre-commit hook started at $(date)" > "$LOG_FILE"
fi

# Gate 1: Package validation (only if package.json staged)
if ! run_gate "Validating package.json" "pnpm validate:package" "has_staged_file '^package.json$'"; then
  show_failure "package.json validation" "pnpm validate:package"
fi

# Gate 2: Environment validation (only if env/config files staged)
ENV_PATTERNS="package.json|next.config|tsconfig.json|\.env\.example|\.env\.test|config/.*env"
if ! run_gate "Validating environment" "NODE_ENV=development pnpm validate:env" "git diff --cached --name-only | grep -qE '$ENV_PATTERNS'"; then
  show_failure "environment validation" "NODE_ENV=development pnpm validate:env"
fi

# Gate 3: Lint staged files (always run - fast and scoped)
if ! run_gate "Linting staged files" "pnpm lint-staged" ""; then
  show_failure "lint-staged" "pnpm lint-staged"
fi

# Gate 4: Typecheck staged files (only if TS/TSX or tsconfig staged)
TYPECHECK_CONDITION="has_staged_file '\.(ts|tsx)$' || has_staged_file '^tsconfig'"
if ! run_gate "Typechecking staged files" "pnpm typecheck:staged" "$TYPECHECK_CONDITION"; then
  show_failure "typecheck:staged" "pnpm typecheck:staged"
fi

# Gate 5: Leak guard (only if types/shared/** staged)
if has_staged_file '^types/shared/'; then
  echo "ğŸ” Checking for type leaks..."
  LEAK_OUTPUT=$(git grep -nE "export .*Database" -- types/shared 2>/dev/null || true)
  if [ -n "$LEAK_OUTPUT" ]; then
    echo "âŒ FATAL: Critical type 'Database' is being re-exported from types/shared."
    echo "  This violates architectural boundaries. Please import it from its source."
    echo ""
    echo "ğŸ“‹ Matching lines:"
    echo "$LEAK_OUTPUT" | while IFS= read -r line; do
      echo "  $line"
    done
    exit 1
  fi
  echo "âœ… Leak guard passed"
fi

echo "âœ… All pre-commit gates passed!"
