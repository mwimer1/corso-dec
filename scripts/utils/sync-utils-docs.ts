#!/usr/bin/env tsx
/**
 * Sync Utils Docs (no barrels)
 *
 * - Scans scripts/utils for .ts files (excluding index.ts, README.md, _tools)
 * - Generates README.md only (no index.ts barrel)
 * - Updates root scripts/README.md "/utils" row with actual count
 *
 * Idempotent & safe: re-run anytime.
 * Deterministic output across platforms (LF newlines, stable sorting).
 */
import { promises as fs } from 'node:fs';
import * as path from 'node:path';

const ROOT = path.resolve('.');
const UTILS_DIR = path.join(ROOT, 'scripts', 'utils');
const TOOLS_DIR = path.join(UTILS_DIR, '_tools');
const UTILS_README = path.join(UTILS_DIR, 'README.md');
// Barrel generation removed by policy.
const SCRIPTS_README = path.join(ROOT, 'scripts', 'README.md');

const IGNORED_ENTRIES = new Set(['index.ts', 'README.md', '_tools']);

// Ensure consistent line endings across platforms
const EOL = '\n';

function toTitle(slug: string): string {
  return slug
    .replace(/-/g, ' ')
    .replace(/\b\w/g, (m) => m.toUpperCase());
}

function categorize(baseName: string): string {
  if (baseName.includes('barrel')) return 'Barrel Management';
  if (baseName.startsWith('bundle-') || baseName.includes('bundle')) return 'Bundle Analysis';
  if (baseName.startsWith('env-') || baseName.includes('debug-env')) return 'Environment Validation';
  if (['logger', 'lastUpdated'].some((k) => baseName.includes(k))) return 'File Processing';
  if (baseName.includes('validation-common')) return 'Validation';
  return 'Misc';
}

async function listUtilsFiles(): Promise<string[]> {
  const entries = await fs.readdir(UTILS_DIR, { withFileTypes: true });
  return entries
    .filter((e) => e.isFile() && e.name.endsWith('.ts') && !IGNORED_ENTRIES.has(e.name))
    .map((e) => e.name)
    // Ensure deterministic order across OS/filesystems
    .sort((a, b) => a.localeCompare(b, 'en'));
}

// Barrel generation removed by policy.

function buildReadme(files: string[]): string {
  const today = new Date().toISOString().slice(0, 10);
  const groups = new Map<string, string[]>();
  for (const f of files) {
    const base = f.replace(/\.ts$/, '');
    const cat = categorize(base);
    if (!groups.has(cat)) groups.set(cat, []);
    groups.get(cat)!.push(base);
  }

  const order = [
    'Barrel Management',
    'Bundle Analysis',
    'Environment Validation',
    'File Processing',
    'Validation',
    'Specialized',
    'Misc',
  ];

  const sections = order
    .filter((c) => groups.has(c))
    .map((cat) => {
      const items = groups
        .get(cat)!
        .map((base) => `- \`${base}.ts\` â€” ${toTitle(base)}`)
        .join(EOL);
      return `### ${cat}\n\n${items}\n`;
    })
    .join(EOL);

  return `---\n` +
    `title: "Utils Scripts"\n` +
    `description: "Shared utility scripts and common patterns for automation, validation, and file processing across the Corso platform."\n` +
    `last_updated: ${today}\n` +
    `category: automation\n` +
    `---\n\n` +
    `# Utils Scripts\n\n` +
    `> Shared utility scripts and common patterns for automation, validation, and file processing across the Corso platform.\n\n` +
    `Total scripts: ${files.length}\n\n` +
    `## Catalog\n\n` +
    `${sections}\n` +
    `## Usage\n\n` +
    `Import specific utilities directly (no barrels):\n\n` +
    '```ts\n' +
    `import { logger } from './logger';\n` +
    `import { git } from './git';\n` +
    '```\n\n' +
    `> This page is auto-generated by \`scripts/utils/sync-utils-docs.ts\`.\n`;
}

function normalizeText(input: string): string {
  // Normalize EOLs, trim trailing spaces, ensure single trailing newline for deterministic output
  const eolNormalized = input.replace(/\r\n/g, EOL).replace(/\r/g, EOL);
  const trimmedEnd = eolNormalized.replace(/[ \t]+\n/g, EOL).replace(/\s+$/g, '');
  return `${trimmedEnd}${EOL}`;
}

function updateScriptsReadmeTable(content: string, count: number): string {
  // Try to replace the third column (Scripts) for the /utils row.
  // Pattern variant 1: bold + backticks: | **`/utils`** | ... | N scripts | ... |
  const patterns: RegExp[] = [
    /(\|\s*\*\*`\/utils`\*\*\s*\|\s*[^|]*\|\s*)[^|]*(\s*\|\s*[^|]*\|)/,
    // Pattern variant 2: backticks only
    /(\|\s*`\/utils`\s*\|\s*[^|]*\|\s*)[^|]*(\s*\|\s*[^|]*\|)/,
    // Pattern variant 3: plain text
    /(\|\s*\/utils\s*\|\s*[^|]*\|\s*)[^|]*(\s*\|\s*[^|]*\|)/,
  ];
  for (const re of patterns) {
    if (re.test(content)) {
      return content.replace(re, (_m, p1: string, p2: string) => `${p1}${count} scripts${p2}`);
    }
  }
  return content; // row not found; no-op
}

async function isManualReadme(): Promise<boolean> {
  try {
    const content = await fs.readFile(UTILS_README, 'utf8');
    // Check for indicators of manual enhancement (not auto-generated)
    const manualIndicators = [
      'ðŸ¤– AI Agent Notes',
      'Core Principle: Importable Utilities Only',
      'Important Distinctions',
      'When to Use Each'
    ];
    return manualIndicators.some(indicator => content.includes(indicator));
  } catch {
    return false;
  }
}

async function main(): Promise<void> {
  const args = new Set(process.argv.slice(2));
  const CHECK_ONLY = args.has('--check');

  const files = await listUtilsFiles();
  const readme = normalizeText(buildReadme(files));

  await fs.mkdir(TOOLS_DIR, { recursive: true });

  // Skip README generation if manually enhanced
  const hasManualReadme = await isManualReadme();
  if (hasManualReadme && !CHECK_ONLY) {
    console.log('[sync-utils-docs] Manual README detected - skipping generation');
    console.log('[sync-utils-docs] Use --check to validate file count only');
    return;
  }

  if (CHECK_ONLY) {
    // Compare current on-disk content with generated content; exit 1 on drift.
    const [curReadme] = await Promise.allSettled([
      fs.readFile(UTILS_README, 'utf8'),
    ]);

    const rmd = curReadme.status === 'fulfilled' ? normalizeText(curReadme.value) : '';
    let drift = false;
    let hasManualEnhancement = false;

    if (rmd !== readme) {
      // Check if the difference is due to manual enhancement (more comprehensive content)
      const manualIndicators = [
        'ðŸ¤– AI Agent Notes',
        'Core Principle: Importable Utilities Only',
        'Important Distinctions',
        'When to Use Each'
      ];
      hasManualEnhancement = manualIndicators.some(indicator => rmd.includes(indicator));

      if (!hasManualEnhancement) {
        drift = true;
      }
    }

    // Also check the root table row if present
    try {
      const sr = await fs.readFile(SCRIPTS_README, 'utf8');
      const updated = updateScriptsReadmeTable(sr, files.length);
      if (normalizeText(updated) !== normalizeText(sr)) drift = true;
    } catch {
      // scripts/README.md optional; ignore
    }

    console.log(`[sync-utils-docs] utils files: ${files.length} (check, no barrels)`);
    if (drift && !hasManualEnhancement) {
      console.error('[sync-utils-docs] Drift detected. Run: pnpm scripts:sync:utils');
      process.exit(1);
    } else if (hasManualEnhancement) {
      console.log('[sync-utils-docs] Manual enhancement detected - drift is expected and beneficial');
    }
    return;
  }

  // Write mode (README only) - ensure LF newlines
  await fs.writeFile(UTILS_README, readme, 'utf8');

  try {
    const sr = await fs.readFile(SCRIPTS_README, 'utf8');
    const upd = updateScriptsReadmeTable(sr, files.length);
    if (upd !== sr) {
      await fs.writeFile(SCRIPTS_README, upd, 'utf8');
    }
  } catch {
    // scripts/README.md may not exist; ignore
  }

  console.log(`[sync-utils-docs] utils files: ${files.length} (write, no barrels)`);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});



