#!/usr/bin/env tsx
/**
 * Audits GitHub Actions workflows for secrets usage and generates security report.
 * 
 * Runs gitleaks to detect secrets in the repository, then audits workflow files
 * to ensure secrets are properly referenced (not hardcoded) and generates a report.
 * 
 * Intent: Ensure secrets are properly managed in CI/CD workflows
 * Files: YAML files in .github/workflows directory
 * Invocation: pnpm audit:secrets
 */
import { spawnSync } from "node:child_process";
import { existsSync, readdirSync, readFileSync, writeFileSync } from "node:fs";
import path, { basename, dirname, extname, resolve } from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const cfg = resolve(process.cwd(), "config/.gitleaks.toml");
const args = ["detect", "--source", ".", "--verbose"];
if (existsSync(cfg)) args.splice(1, 0, "--config", cfg);

const run = spawnSync("gitleaks", args, { stdio: "inherit", shell: true });
if (run.error || run.status !== 0) {
  console.error(
    "gitleaks not found or scan failed. Install it via `pnpm tools:gitleaks:install` and re-run."
  );
  process.exitCode = run.status ?? 1;
  // Continue to workflow audit even if gitleaks fails
}

const WORKFLOWS_DIR = '.github/workflows';
const REPORT_FILE = 'workflow-secrets-audit.md';

function redactSecrets(input: string): string {
  return input.replace(/secrets\.[A-Z_][A-Z0-9_]*/g, 'secrets.***');
}

console.log('üîç Auditing GitHub Actions workflows for secrets usage...');
console.log(`Scanning directory: ${WORKFLOWS_DIR}`);
console.log('');

// Initialize report
let report = `# GitHub Actions Secrets Usage Audit Report

> **Generated**: ${new Date().toISOString()}  
> **Purpose**: Security audit of secrets usage across all workflows

## Executive Summary

This report identifies all GitHub Actions workflows that use secrets and analyzes their security posture for fork protection.

## Findings

`;

let secretWorkflows = 0;
let protectedWorkflows = 0;
let totalWorkflows = 0;

const files = readdirSync(WORKFLOWS_DIR).filter(f => f.endsWith('.yml') || f.endsWith('.yaml'));

for (const file of files) {
  const fullPath = path.join(WORKFLOWS_DIR, file);
  const content = readFileSync(fullPath, 'utf8');
  const workflowName = basename(file, extname(file));
  
  totalWorkflows++;
  
  const hasSecrets = /\$\{\{ secrets\./.test(content);
  const secretsList = content.match(/\$\{\{ secrets\.[A-Z_][A-Z0-9_]* \}\}/g) || [];
  const uniqueSecrets = [...new Set(secretsList)];
  
  const hasForkProtection = /github\.event\.pull_request\.head\.repo\.full_name/.test(content) || 
                            /github\.event_name.*push/.test(content);
  
  if (hasSecrets) {
    secretWorkflows++;
    if (hasForkProtection) protectedWorkflows++;
    
    report += `
### ${workflowName}

- **Secrets Used**: ${uniqueSecrets.length}
- **Fork Protection**: ${hasForkProtection ? '‚úÖ Implemented' : '‚ùå Missing'}
- **Security Level**: ${hasForkProtection ? 'üü¢ Secure' : 'üü° Needs Review'}

**Secrets Detected:**
`;
    for (const secret of uniqueSecrets) {
      const redacted = redactSecrets(secret);
      report += `- \`${redacted}\`\n`;
    }
    
    if (!hasForkProtection) {
      report += `
**‚ö†Ô∏è Security Recommendation:**
This workflow uses secrets but lacks fork protection. Consider adding:
\`\`\`yaml
# Add to secret-using steps
if: always() && (github.event_name == 'push' || github.event.pull_request.head.repo.full_name == github.repository)
\`\`\`

`;
    }
  }
}

// Add summary
report += `
## Security Summary

| Metric | Count | Percentage |
|--------|-------|------------|
| **Total Workflows** | ${totalWorkflows} | 100% |
| **Workflows Using Secrets** | ${secretWorkflows} | ${Math.round(secretWorkflows * 100 / totalWorkflows)}% |
| **Protected Secret Workflows** | ${protectedWorkflows} | ${secretWorkflows > 0 ? Math.round(protectedWorkflows * 100 / secretWorkflows) : 0}% |

## Security Score

${secretWorkflows === 0 ? '**üü¢ Excellent (No secrets used)**' : 
  protectedWorkflows === secretWorkflows ? '**üü¢ Excellent (All secret workflows protected)**' : 
  protectedWorkflows > (secretWorkflows / 2) ? '**üü° Good (Most secret workflows protected)**' : 
  '**üî¥ Needs Improvement (Many unprotected secret workflows)**'}

## Recommendations

1. **Implement fork protection** for all workflows using secrets
2. **Use step-level secret injection** instead of job-level
3. **Add graceful degradation** for fork PRs
4. **Regular security audits** using this script
5. **Document secrets usage** in security documentation

## Next Steps

- [ ] Review workflows marked as "Needs Review"
- [ ] Implement fork protection where missing
- [ ] Update security documentation
- [ ] Schedule quarterly security audits

---

**Generated by**: \`scripts/lint/audit-workflow-secrets.ts\`  
**Next Audit**: ${new Date(new Date().setMonth(new Date().getMonth() + 3)).toISOString().split('T')[0]}
`;

writeFileSync(REPORT_FILE, report);

console.log('');
console.log('üìä Audit Summary:');
console.log(`  Total workflows: ${totalWorkflows}`);
console.log(`  Workflows using secrets: ${secretWorkflows}`);
console.log(`  Protected workflows: ${protectedWorkflows}`);
console.log('');
console.log(`üìÑ Full report generated: ${REPORT_FILE}`);

if (secretWorkflows > protectedWorkflows) {
  console.log(`‚ö†Ô∏è  Warning: ${secretWorkflows - protectedWorkflows} workflows use secrets without fork protection`);
  process.exitCode = 1;
} else {
  console.log('‚úÖ Security audit completed successfully');
} 

