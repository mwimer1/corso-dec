#!/usr/bin/env tsx
/**
 * CI check to ensure generated documentation stays in sync with source code.
 * 
 * Runs documentation generators and checks if any files were modified.
 * Fails if generated docs are out of sync, indicating they need to be regenerated.
 * 
 * Intent: Ensure generated docs are always up-to-date
 * Files: eslint-plugin-corso/README.md, scripts/lint/README.md, scripts/rules/ast-grep/README.md
 * Invocation: pnpm docs:check:sync (CI only)
 */

import { execSync } from 'node:child_process';
import { existsSync } from 'node:fs';
import { join } from 'node:path';
import { fileURLToPath } from 'node:url';
import { dirname } from 'node:path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const repoRoot = join(__dirname, '../..');

/**
 * Files that should be checked for changes after generation
 */
const GENERATED_DOCS = [
  'docs/index.ts', // Main docs index (generated by docs:index)
  'eslint-plugin-corso/README.md',
  'scripts/lint/README.md',
  'scripts/rules/ast-grep/README.md',
  // Scripts READMEs are generated by docs:generate:readme
  // We'll check them dynamically since the list can change
];

async function main() {
  console.log('üìñ Checking if generated documentation is in sync...\n');

  // Check if we're in a git repository
  try {
    execSync('git rev-parse --git-dir', { stdio: 'ignore', cwd: repoRoot });
  } catch {
    console.warn('‚ö†Ô∏è  Not in a git repository. Skipping sync check.');
    console.log('‚úÖ Documentation generation completed (no git to check sync)');
    return;
  }

  // Get initial state of generated docs (will be populated after we find all docs)
  const initialStatus = new Map<string, string>();
  
  // First, find all scripts READMEs
  const { readdirSync: readdirSyncSync, statSync: statSyncSync } = await import('node:fs');
  const { join: joinSync } = await import('node:path');
  
  function findScriptsReadmesSync(dir: string, basePath = ''): string[] {
    const readmes: string[] = [];
    try {
      const entries = readdirSyncSync(dir);
      for (const entry of entries) {
        const fullPath = joinSync(dir, entry);
        const relativePath = joinSync(basePath, entry).replace(/\\/g, '/');
        try {
          const stat = statSyncSync(fullPath);
          if (stat.isDirectory() && !entry.startsWith('.') && entry !== 'node_modules') {
            readmes.push(...findScriptsReadmesSync(fullPath, relativePath));
          } else if (entry === 'README.md' && basePath.startsWith('scripts/')) {
            readmes.push(relativePath);
          }
        } catch {
          // Skip files we can't access
        }
      }
    } catch {
      // Skip directories we can't access
    }
    return readmes;
  }
  
  const scriptsReadmes = findScriptsReadmesSync(joinSync(repoRoot, 'scripts'));
  const allGeneratedDocs = [...GENERATED_DOCS, ...scriptsReadmes];
  
  for (const doc of allGeneratedDocs) {
    const docPath = join(repoRoot, doc);
    if (existsSync(docPath)) {
      try {
        const content = execSync('git diff HEAD -- ' + doc, {
          encoding: 'utf8',
          cwd: repoRoot,
          stdio: ['pipe', 'pipe', 'ignore'],
        });
        initialStatus.set(doc, content);
      } catch {
        // File might not be tracked yet
        initialStatus.set(doc, '');
      }
    }
  }

  // Run documentation generators
  console.log('üîÑ Running documentation generators...\n');
  try {
    // Update docs index (generates docs/index.ts)
    execSync('pnpm docs:index', {
      cwd: repoRoot,
      stdio: 'inherit',
    });
    
    // Generate scripts READMEs
    execSync('pnpm docs:generate:readme -- --all', {
      cwd: repoRoot,
      stdio: 'inherit',
    });
    
    // Generate lint docs (eslint-plugin, ast-grep, etc.)
    execSync('pnpm docs:generate:lint', {
      cwd: repoRoot,
      stdio: 'inherit',
    });
  } catch (error) {
    console.error('‚ùå Failed to generate documentation');
    process.exitCode = 1;
    return;
  }
  
  // Check for changes
  const changes: string[] = [];
  for (const doc of allGeneratedDocs) {
    const docPath = join(repoRoot, doc);
    if (!existsSync(docPath)) {
      changes.push(`Missing: ${doc}`);
      continue;
    }

    try {
      const currentContent = execSync('git diff HEAD -- ' + doc, {
        encoding: 'utf8',
        cwd: repoRoot,
        stdio: ['pipe', 'pipe', 'ignore'],
      });

      const initialContent = initialStatus.get(doc) || '';
      if (currentContent !== initialContent) {
        // Check if there are actual changes (not just whitespace)
        const hasRealChanges = currentContent.trim().length > 0 &&
          currentContent
            .split('\n')
            .some(line => line.startsWith('+') || line.startsWith('-'));

        if (hasRealChanges) {
          changes.push(doc);
        }
      }
    } catch {
      // File might not be tracked, check if it exists and has content
      try {
        const { readFileSync } = require('node:fs');
        const content = readFileSync(docPath, 'utf-8');
        if (content.trim().length > 0 && !initialStatus.has(doc)) {
          changes.push(`New file: ${doc}`);
        }
      } catch {
        // Ignore read errors
      }
    }
  }

  // Report results
  if (changes.length > 0) {
    console.error('\n‚ùå Generated documentation is out of sync!\n');
    console.error('The following files have uncommitted changes:');
    for (const change of changes) {
      console.error(`  - ${change}`);
    }
    console.error('\nüí° To fix:');
    console.error('  1. Run: pnpm docs:generate:lint');
    console.error('  2. Review and commit the changes');
    console.error('\nüí° To check locally:');
    console.error('  pnpm docs:index');
    console.error('  pnpm docs:generate:readme -- --all');
    console.error('  pnpm docs:generate:lint');
    console.error('  git diff -- docs/index.ts scripts/**/README.md eslint-plugin-corso/README.md');
    process.exitCode = 1;
  } else {
    console.log('\n‚úÖ Generated documentation is in sync!');
  }
}

void main();
