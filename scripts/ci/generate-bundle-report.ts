#!/usr/bin/env tsx
/**
 * Generate bundle size comparison report
 * 
 * Compares current bundle size against base branch and generates a markdown report.
 * 
 * Contract:
 * - --current: Required. Path to JSON file containing current bundle analysis data.
 *   Expected format: BundleAnalysisData (from bundle-analysis-common.ts)
 *   Generated by: `pnpm bundlesize:ci > bundle-size-current.json`
 * - --base: Optional. Path to JSON file containing base branch bundle analysis data.
 *   Same format as --current. If omitted, report shows current size only.
 *   Generated by: `pnpm bundlesize:ci > bundle-size-base.json`
 * - --output: Optional. Path where markdown report will be written.
 *   If omitted, report is printed to stdout.
 * 
 * Output:
 * - Markdown file (if --output specified) or stdout (if omitted)
 * - Format: Summary with comparison, current bundle analysis, largest files table
 * 
 * Usage:
 *   tsx scripts/ci/generate-bundle-report.ts \
 *     --current=bundle-size-current.json \
 *     --base=bundle-size-base.json \
 *     --output=bundle-report.md
 */

import fs from 'node:fs';
import { compareBundleSizes, formatBytes, type BundleAnalysisData } from '../utils/bundle-analysis-common';

interface Args {
  current?: string;
  base?: string;
  output?: string;
}

function parseArgs(): Args {
  const args: Args = {};
  for (let i = 2; i < process.argv.length; i++) {
    const arg = process.argv[i];
    if (!arg) continue;
    if (arg.startsWith('--current=')) {
      const value = arg.split('=')[1];
      if (value) args.current = value;
    } else if (arg.startsWith('--base=')) {
      const value = arg.split('=')[1];
      if (value) args.base = value;
    } else if (arg.startsWith('--output=')) {
      const value = arg.split('=')[1];
      if (value) args.output = value;
    }
  }
  return args;
}

function loadBundleData(filePath: string): BundleAnalysisData | null {
  if (!fs.existsSync(filePath)) {
    console.warn(`Warning: Bundle data file not found: ${filePath}`);
    return null;
  }

  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const data = JSON.parse(content);
    
    // Handle both formats: direct BundleAnalysisData or wrapped in object
    if (data.totalGzippedSize !== undefined) {
      return data as BundleAnalysisData;
    } else if (data.totalSize !== undefined && data.totalGzippedSize !== undefined) {
      return data as BundleAnalysisData;
    } else {
      // Try to extract from check-bundle-size.ts JSON output format
      // If bundlesize:ci outputs JSON, it might have a different structure
      return {
        totalSize: data.totalSize || 0,
        totalGzippedSize: data.totalGzippedSize || data.totalGzip || 0,
        files: data.files || []
      };
    }
  } catch (error) {
    console.error(`Error reading bundle data from ${filePath}:`, error);
    return null;
  }
}

function generateReport(current: BundleAnalysisData, base: BundleAnalysisData | null): string {
  const comparison = base !== null
    ? compareBundleSizes(base.totalGzippedSize, current.totalGzippedSize, 5)
    : null;

  let report = '# Bundle Size Report\n\n';
  
  if (comparison && base !== null) {
    report += `## Summary\n\n`;
    report += `- **Current Size:** ${formatBytes(current.totalGzippedSize)}\n`;
    report += `- **Base Size:** ${formatBytes(base.totalGzippedSize)}\n`;
    report += `- **Change:** ${comparison.isIncrease ? '+' : '-'}${comparison.diffFormatted} (${comparison.diffPercent > 0 ? '+' : ''}${comparison.diffPercent}%)\n\n`;
    
    if (comparison.isSignificant) {
      report += `⚠️ **Significant change detected** (${Math.abs(comparison.diffPercent)}% ${comparison.isIncrease ? 'increase' : 'decrease'})\n\n`;
    } else {
      report += `✅ Change is within acceptable threshold (< 5%)\n\n`;
    }
  } else {
    report += `## Summary\n\n`;
    report += `- **Current Size:** ${formatBytes(current.totalGzippedSize)}\n`;
    report += `- **Base Size:** Not available\n\n`;
  }

  report += `## Current Bundle Analysis\n\n`;
  report += `- **Total Files:** ${current.files.length}\n`;
  report += `- **Total Size (Raw):** ${formatBytes(current.totalSize)}\n`;
  report += `- **Total Size (Gzipped):** ${formatBytes(current.totalGzippedSize)}\n\n`;

  if (current.files.length > 0) {
    report += `## Largest Files\n\n`;
    report += `| File | Raw Size | Gzipped Size |\n`;
    report += `|------|----------|--------------|\n`;
    
    const sortedFiles = [...current.files].sort((a, b) => {
      const aSize = a.gzippedSize || a.gzipSize || 0;
      const bSize = b.gzippedSize || b.gzipSize || 0;
      return bSize - aSize;
    });

    sortedFiles.slice(0, 20).forEach(file => {
      const name = file.path || file.name || 'unknown';
      const raw = formatBytes(file.rawSize || file.size || 0);
      const gzip = formatBytes(file.gzippedSize || file.gzipSize || 0);
      report += `| ${name} | ${raw} | ${gzip} |\n`;
    });
  }

  return report;
}

function main() {
  const args = parseArgs();

  if (!args.current) {
    console.error('Error: --current argument is required');
    console.error('Usage: tsx scripts/ci/generate-bundle-report.ts --current=<file> --base=<file> --output=<file>');
    process.exit(1);
  }

  const currentData = loadBundleData(args.current);
  if (!currentData) {
    console.error('Error: Could not load current bundle data');
    process.exit(1);
  }

  const baseData = args.base ? loadBundleData(args.base) : null;

  const report = generateReport(currentData, baseData);

  if (args.output) {
    fs.writeFileSync(args.output, report, 'utf8');
    console.log(`✅ Bundle report written to ${args.output}`);
  } else {
    console.log(report);
  }
}

main();

