#!/usr/bin/env tsx
// scripts/maintenance/styles-comprehensive-audit.ts
// Comprehensive audit and fix system for the entire styles directory
// Validates design tokens, variant factories, documentation, and barrel exports

import { glob } from 'glob';
import { execSync } from 'node:child_process';
import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'url';

// ESM-compatible __dirname polyfill
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '../..');

interface AuditResult {
  phase: string;
  success: boolean;
  issues: string[];
  fixes: string[];
  warnings: string[];
}

interface ComprehensiveAuditReport {
  timestamp: string;
  phases: AuditResult[];
  summary: {
    totalIssues: number;
    totalFixes: number;
    totalWarnings: number;
    overallSuccess: boolean;
  };
}

class StylesAuditor {
  private results: AuditResult[] = [];
  private autoFix: boolean;

  constructor(autoFix = false) {
    this.autoFix = autoFix;
  }

  private log(message: string, type: 'info' | 'error' | 'warning' | 'success' = 'info') {
    const prefix = {
      info: 'üîç',
      error: '‚ùå',
      warning: '‚ö†Ô∏è',
      success: '‚úÖ'
    }[type];
    console.log(`${prefix} ${message}`);
  }

  private async createPhaseResult(phase: string): Promise<AuditResult> {
    return {
      phase,
      success: true,
      issues: [],
      fixes: [],
      warnings: []
    };
  }

  // Phase 1: Core Design System Infrastructure
  async auditCoreInfrastructure(): Promise<AuditResult> {
    const result = await this.createPhaseResult('Core Design System Infrastructure');
    this.log('üé® Phase 1: Auditing core design system infrastructure...');

    try {
      // Audit styles/README.md
      await this.auditStylesReadme(result);

      // Audit styles/index.ts exports
      await this.auditStylesIndex(result);

      // Audit styles/component-variants.ts autogenerated file
      await this.auditVariantsFile(result);

      // Audit design tokens
      await this.auditDesignTokens(result);

    } catch (error) {
      result.success = false;
      result.issues.push(`Core infrastructure audit failed: ${error}`);
    }

    return result;
  }

  // Phase 2: Component Variant Factories
  async auditVariantFactories(): Promise<AuditResult> {
    const result = await this.createPhaseResult('Component Variant Factories');
    this.log('üß© Phase 2: Auditing component variant factories...');

    try {
      // Audit UI directory structure
      await this.auditUIDirectoryStructure(result);

      // Audit atomic variants
      await this.auditAtomicVariants(result);

      // Audit molecular variants
      await this.auditMolecularVariants(result);

      // Audit organism variants
      await this.auditOrganismVariants(result);

    } catch (error) {
      result.success = false;
      result.issues.push(`Variant factories audit failed: ${error}`);
    }

    return result;
  }

  // Phase 3: Utilities & Build System
  async auditUtilitiesAndBuild(): Promise<AuditResult> {
    const result = await this.createPhaseResult('Utilities & Build System');
    this.log('üîß Phase 3: Auditing utilities and build system...');

    try {
      // Audit utils directory
      await this.auditUtilsDirectory(result);

      // Audit build artifacts
      await this.auditBuildArtifacts(result);

      // Audit fonts and globals
      await this.auditFontsAndGlobals(result);

      // Validate build process
      await this.validateBuildProcess(result);

    } catch (error) {
      result.success = false;
      result.issues.push(`Utilities and build audit failed: ${error}`);
    }

    return result;
  }

  // Detailed audit methods
  private async auditStylesReadme(result: AuditResult): Promise<void> {
    const readmePath = path.join(projectRoot, 'styles/README.md');

    try {
      const content = await fs.readFile(readmePath, 'utf-8');

      // Check for required sections
      const requiredSections = [
        '# üé® Styles Directory',
        '## üìÅ Directory Structure',
        '## üß© Architecture Principles',
        'last_updated'
      ];

      for (const section of requiredSections) {
        if (!content.includes(section)) {
          result.issues.push(`styles/README.md missing required section: ${section}`);
        }
      }

      // Check if last_updated is recent (within 30 days)
      const lastUpdatedMatch = content.match(/last_updated:\s*(\d{4}-\d{2}-\d{2})/);
      if (lastUpdatedMatch?.[1]) {
        const lastUpdated = new Date(lastUpdatedMatch[1]);
        const daysSinceUpdate = (Date.now() - lastUpdated.getTime()) / (1000 * 60 * 60 * 24);
        if (daysSinceUpdate > 30) {
          result.warnings.push(`styles/README.md last updated ${Math.floor(daysSinceUpdate)} days ago`);

          if (this.autoFix) {
            const updatedContent = content.replace(
              /last_updated:\s*\d{4}-\d{2}-\d{2}/,
              `last_updated: ${new Date().toISOString().split('T')[0]}`
            );
            await fs.writeFile(readmePath, updatedContent);
            result.fixes.push('Updated last_updated date in styles/README.md');
          }
        }
      }

    } catch (error) {
      result.issues.push(`Failed to audit styles/README.md: ${error}`);
    }
  }

  private async auditStylesIndex(result: AuditResult): Promise<void> {
    const indexPath = path.join(projectRoot, 'styles/index.ts');

    try {
      const content = await fs.readFile(indexPath, 'utf-8');

      // Check for required exports (direct exports instead of wildcard)
      const requiredExports = [
        "export { latoVariable } from './fonts'",
        "export { cn } from './utils'",
        "export { accountMenuVariants, contactFormVariants,",
        "export { navbarLayout as dashboardNavbar } from"
      ];

      for (const exportStmt of requiredExports) {
        if (!content.includes(exportStmt)) {
          result.issues.push(`styles/index.ts missing required export pattern: ${exportStmt}`);
        }
      }

      // Verify referenced modules exist
      const modulesToCheck = [
        path.join(projectRoot, 'styles/fonts.ts'),
        path.join(projectRoot, 'styles/utils.ts'),
        path.join(projectRoot, 'styles/ui/organisms/index.ts')
      ];

      for (const modulePath of modulesToCheck) {
        try {
          await fs.access(modulePath);
        } catch {
          result.issues.push(`Referenced module does not exist: ${modulePath}`);
        }
      }

    } catch (error) {
      result.issues.push(`Failed to audit styles/index.ts: ${error}`);
    }
  }

  private async auditVariantsFile(result: AuditResult): Promise<void> {
    const variantsPath = path.join(projectRoot, 'styles/ui/shared/component-variants.ts');

    try {
      const content = await fs.readFile(variantsPath, 'utf-8');

      // Check if file is marked as autogenerated
      if (!content.includes('THIS FILE IS AUTOGENERATED')) {
        result.warnings.push('styles/ui/shared/component-variants.ts should be marked as autogenerated');
      }

      // Verify all variant files referenced actually exist
      const exportMatches = content.match(/export \* from '\.\/ui\/[^']+'/g) || [];

      for (const exportMatch of exportMatches) {
        const relativePath = exportMatch.match(/'([^']+)'/)?.[1];
        if (relativePath) {
          const fullPath = path.join(projectRoot, 'styles', relativePath + '.ts');
          try {
            await fs.access(fullPath);
          } catch {
            result.issues.push(`styles/ui/shared/component-variants.ts references non-existent file: ${relativePath}.ts`);
          }
        }
      }

      // Check if variants file needs regeneration
      if (this.autoFix) {
        try {
          execSync('pnpm gen:variants', { cwd: projectRoot, stdio: 'pipe' });
          result.fixes.push('Regenerated styles/ui/shared/component-variants.ts');
        } catch (error) {
          result.warnings.push('Failed to regenerate component variants file');
        }
      }

    } catch (error) {
      result.issues.push(`Failed to audit styles/ui/shared/component-variants.ts: ${error}`);
    }
  }

  private async auditDesignTokens(result: AuditResult): Promise<void> {
    const tokensDir = path.join(projectRoot, 'styles/tokens');

    try {
      const tokenFiles = await glob('*.css', { cwd: tokensDir });
      const requiredTokenFiles = [
        'colors.css',
        'typography.css',
        'spacing.css',
        'shadows.css',
        'radius.css',
        'animation.css',
        'index.css'
      ];

      // Check for missing token files
      for (const required of requiredTokenFiles) {
        if (!tokenFiles.includes(required)) {
          result.issues.push(`Missing required token file: styles/tokens/${required}`);
        }
      }

      // Audit individual token files
      for (const tokenFile of tokenFiles) {
        await this.auditTokenFile(path.join(tokensDir, tokenFile), result);
      }

      // Audit tokens README
      const tokensReadmePath = path.join(tokensDir, 'README.md');
      try {
        await fs.access(tokensReadmePath);
      } catch {
        result.issues.push('Missing styles/tokens/README.md');
      }

    } catch (error) {
      result.issues.push(`Failed to audit design tokens: ${error}`);
    }
  }

  private async auditTokenFile(filePath: string, result: AuditResult): Promise<void> {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      const fileName = path.basename(filePath);

      // Check for CSS custom property syntax
      const customPropertyPattern = /--[a-zA-Z0-9-]+:/g;
      const properties = content.match(customPropertyPattern) || [];

      if (properties.length === 0 && fileName !== 'index.css') {
        result.warnings.push(`${fileName} contains no CSS custom properties`);
      }

      // Check for common CSS syntax errors
      const unclosedBraces = (content.match(/{/g) || []).length - (content.match(/}/g) || []).length;
      if (unclosedBraces !== 0) {
        result.issues.push(`${fileName} has unmatched braces`);
      }

      // Validate color values in colors.css
      if (fileName === 'colors.css') {
        const colorValues = content.match(/:\s*#[0-9a-fA-F]{6}|:\s*rgb\([^)]+\)|:\s*hsl\([^)]+\)/g) || [];
        if (colorValues.length === 0) {
          result.warnings.push('colors.css contains no recognizable color values');
        }
      }

    } catch (error) {
      result.issues.push(`Failed to audit token file ${filePath}: ${error}`);
    }
  }

  private async auditUIDirectoryStructure(result: AuditResult): Promise<void> {
    const uiDir = path.join(projectRoot, 'styles/ui');

    try {
      const requiredDirs = ['atoms', 'molecules', 'organisms'];

      for (const dir of requiredDirs) {
        const dirPath = path.join(uiDir, dir);
        try {
          await fs.access(dirPath);

          // Check for index.ts in each directory
          const indexPath = path.join(dirPath, 'index.ts');
          try {
            await fs.access(indexPath);
          } catch {
            result.issues.push(`Missing index.ts in styles/ui/${dir}/`);
          }

          // Check for README.md in each directory
          const readmePath = path.join(dirPath, 'README.md');
          try {
            await fs.access(readmePath);
          } catch {
            result.issues.push(`Missing README.md in styles/ui/${dir}/`);
          }

        } catch {
          result.issues.push(`Missing required directory: styles/ui/${dir}/`);
        }
      }

    } catch (error) {
      result.issues.push(`Failed to audit UI directory structure: ${error}`);
    }
  }

  private async auditAtomicVariants(result: AuditResult): Promise<void> {
    const atomsDir = path.join(projectRoot, 'styles/ui/atoms');
    await this.auditVariantDirectory(atomsDir, 'atoms', result);
  }

  private async auditMolecularVariants(result: AuditResult): Promise<void> {
    const moleculesDir = path.join(projectRoot, 'styles/ui/molecules');
    await this.auditVariantDirectory(moleculesDir, 'molecules', result);
  }

  private async auditOrganismVariants(result: AuditResult): Promise<void> {
    const organismsDir = path.join(projectRoot, 'styles/ui/organisms');
    await this.auditVariantDirectory(organismsDir, 'organisms', result);
  }

  private async auditVariantDirectory(dirPath: string, dirName: string, result: AuditResult): Promise<void> {
    try {
      const variantFiles = await glob('*.ts', { cwd: dirPath, ignore: ['index.ts'] });

      for (const variantFile of variantFiles) {
        await this.auditVariantFile(path.join(dirPath, variantFile), result);
      }

      // Audit the index.ts barrel file
      const indexPath = path.join(dirPath, 'index.ts');
      await this.auditBarrelFile(indexPath, variantFiles, result);

    } catch (error) {
      result.issues.push(`Failed to audit ${dirName} variants: ${error}`);
    }
  }

  private async auditVariantFile(filePath: string, result: AuditResult): Promise<void> {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      const fileName = path.basename(filePath);

      // Check for tailwind-variants import
      if (!content.includes('tailwind-variants') && !content.includes('from "tailwind-variants"')) {
        result.warnings.push(`${fileName} may be missing tailwind-variants import`);
      }

      // Check for export statement
      if (!content.includes('export')) {
        result.issues.push(`${fileName} contains no exports`);
      }

      // Check for TypeScript syntax errors (basic)
      const unclosedParens = (content.match(/\(/g) || []).length - (content.match(/\)/g) || []).length;
      if (unclosedParens !== 0) {
        result.issues.push(`${fileName} has unmatched parentheses`);
      }

    } catch (error) {
      result.issues.push(`Failed to audit variant file ${filePath}: ${error}`);
    }
  }

  private async auditBarrelFile(indexPath: string, expectedFiles: string[], result: AuditResult): Promise<void> {
    try {
      const content = await fs.readFile(indexPath, 'utf-8');
      const dirName = path.basename(path.dirname(indexPath));

      // Check that all variant files are exported
      for (const file of expectedFiles) {
        const moduleName = path.basename(file, '.ts');
        const exportPattern = new RegExp(`export.*from.*['"]\\./${moduleName}['"]`);

        if (!exportPattern.test(content)) {
          result.issues.push(`${dirName}/index.ts missing export for ${moduleName}`);

          if (this.autoFix) {
            const newExport = `export * from './${moduleName}';\n`;
            await fs.appendFile(indexPath, newExport);
            result.fixes.push(`Added missing export for ${moduleName} in ${dirName}/index.ts`);
          }
        }
      }

    } catch (error) {
      result.issues.push(`Failed to audit barrel file ${indexPath}: ${error}`);
    }
  }

  private async auditUtilsDirectory(result: AuditResult): Promise<void> {
    const utilsDir = path.join(projectRoot, 'styles/utils');

    try {
      // Check for required files
      const requiredFiles = ['utils.ts', 'index.ts', 'README.md'];

      for (const file of requiredFiles) {
        const filePath = path.join(utilsDir, file);
        try {
          await fs.access(filePath);
        } catch {
          result.issues.push(`Missing required file: styles/utils/${file}`);
        }
      }

      // Audit utils.ts for cn() function
      const utilsPath = path.join(utilsDir, 'utils.ts');
      try {
        const content = await fs.readFile(utilsPath, 'utf-8');
        if (!content.includes('cn')) {
          result.warnings.push('styles/utils/utils.ts may be missing cn() utility function');
        }
      } catch {
        // Already reported as missing file
      }

    } catch (error) {
      result.issues.push(`Failed to audit utils directory: ${error}`);
    }
  }

  private async auditBuildArtifacts(result: AuditResult): Promise<void> {
    const buildDir = path.join(projectRoot, 'styles/build');

    try {
      const expectedFiles = ['globals.css', 'components.css', 'tailwind.css', 'README.md'];

      for (const file of expectedFiles) {
        const filePath = path.join(buildDir, file);
        try {
          await fs.access(filePath);
        } catch {
          result.warnings.push(`Missing build artifact: styles/build/${file}`);
        }
      }

    } catch (error) {
      result.warnings.push(`Failed to audit build artifacts: ${error}`);
    }
  }

  private async auditFontsAndGlobals(result: AuditResult): Promise<void> {
    const stylesDir = path.join(projectRoot, 'styles');

    try {
      // Check for fonts.ts
      const fontsPath = path.join(stylesDir, 'fonts.ts');
      try {
        await fs.access(fontsPath);
      } catch {
        result.issues.push('Missing styles/fonts.ts');
      }

      // Check for globals.css
      const globalsPath = path.join(stylesDir, 'globals.css');
      try {
        await fs.access(globalsPath);
      } catch {
        result.issues.push('Missing styles/globals.css');
      }

    } catch (error) {
      result.issues.push(`Failed to audit fonts and globals: ${error}`);
    }
  }

  private async validateBuildProcess(result: AuditResult): Promise<void> {
    if (this.autoFix) {
      try {
        // Test Tailwind build
        execSync('pnpm tailwind:build', { cwd: projectRoot, stdio: 'pipe' });
        result.fixes.push('Successfully validated Tailwind build process');
      } catch (error) {
        result.issues.push('Failed to validate Tailwind build process');
      }

      try {
        // Test variant generation
        execSync('pnpm gen:variants', { cwd: projectRoot, stdio: 'pipe' });
        result.fixes.push('Successfully validated variant generation');
      } catch (error) {
        result.issues.push('Failed to validate variant generation');
      }
    }
  }

  async runComprehensiveAudit(): Promise<ComprehensiveAuditReport> {
    const startTime = new Date();
    this.log(`üöÄ Starting comprehensive styles audit at ${startTime.toISOString()}`);

    // Run all audit phases
    const phases = await Promise.all([
      this.auditCoreInfrastructure(),
      this.auditVariantFactories(),
      this.auditUtilitiesAndBuild()
    ]);

    this.results = phases;

    // Generate summary
    const totalIssues = phases.reduce((sum, phase) => sum + phase.issues.length, 0);
    const totalFixes = phases.reduce((sum, phase) => sum + phase.fixes.length, 0);
    const totalWarnings = phases.reduce((sum, phase) => sum + phase.warnings.length, 0);
    const overallSuccess = phases.every(phase => phase.success && phase.issues.length === 0);

    const report: ComprehensiveAuditReport = {
      timestamp: startTime.toISOString(),
      phases,
      summary: {
        totalIssues,
        totalFixes,
        totalWarnings,
        overallSuccess
      }
    };

    // Log results
    this.logResults(report);

    // Save audit report
    await this.saveAuditReport(report);

    return report;
  }

  private logResults(report: ComprehensiveAuditReport): void {
    this.log('\nüìä COMPREHENSIVE AUDIT RESULTS', 'info');
    this.log('='.repeat(50), 'info');

    for (const phase of report.phases) {
      const status = phase.success && phase.issues.length === 0 ? 'success' : 'error';
      this.log(`\n${phase.phase}:`, status);

      if (phase.issues.length > 0) {
        this.log(`  Issues (${phase.issues.length}):`, 'error');
        phase.issues.forEach(issue => this.log(`    ‚Ä¢ ${issue}`, 'error'));
      }

      if (phase.fixes.length > 0) {
        this.log(`  Fixes Applied (${phase.fixes.length}):`, 'success');
        phase.fixes.forEach(fix => this.log(`    ‚Ä¢ ${fix}`, 'success'));
      }

      if (phase.warnings.length > 0) {
        this.log(`  Warnings (${phase.warnings.length}):`, 'warning');
        phase.warnings.forEach(warning => this.log(`    ‚Ä¢ ${warning}`, 'warning'));
      }
    }

    this.log('\nüìà SUMMARY:', 'info');
    this.log(`  Total Issues: ${report.summary.totalIssues}`, report.summary.totalIssues > 0 ? 'error' : 'success');
    this.log(`  Total Fixes: ${report.summary.totalFixes}`, 'info');
    this.log(`  Total Warnings: ${report.summary.totalWarnings}`, 'warning');
    this.log(`  Overall Status: ${report.summary.overallSuccess ? 'PASSED' : 'FAILED'}`,
      report.summary.overallSuccess ? 'success' : 'error');
  }

  private async saveAuditReport(report: ComprehensiveAuditReport): Promise<void> {
    const reportDir = path.join(projectRoot, 'test-reports');
    await fs.mkdir(reportDir, { recursive: true });

    const reportPath = path.join(reportDir, `styles-audit-${Date.now()}.json`);
    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));

    this.log(`üìÑ Audit report saved to: ${reportPath}`, 'info');
  }
}

// CLI Interface
async function main() {
  const args = process.argv.slice(2);
  const autoFix = args.includes('--fix') || args.includes('-f');
  const help = args.includes('--help') || args.includes('-h');

  if (help) {
    console.log(`
üé® Styles Comprehensive Audit Tool

Usage: tsx scripts/maintenance/styles-comprehensive-audit.ts [options]

Options:
  --fix, -f     Automatically fix issues where possible
  --help, -h    Show this help message

Phases:
  1. Core Design System Infrastructure
  2. Component Variant Factories
  3. Utilities & Build System

The audit validates:
  ‚úì Documentation accuracy and freshness
  ‚úì Design token consistency
  ‚úì Variant factory implementations
  ‚úì Barrel export completeness
  ‚úì Build process integrity
  ‚úì TypeScript compilation
    `);
    process.exit(0);
  }

  const auditor = new StylesAuditor(autoFix);

  try {
    const report = await auditor.runComprehensiveAudit();

    // Exit with error code if audit failed
    process.exit(report.summary.overallSuccess ? 0 : 1);

  } catch (error) {
    console.error('‚ùå Audit failed with error:', error);
    process.exit(1);
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  void main();
}

export { StylesAuditor, type AuditResult, type ComprehensiveAuditReport };


